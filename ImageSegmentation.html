<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Watershed Image Segmentation</title>
    <style type="text/css">
        /* display loading gif and hide webpage */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: rgba(255, 255, 255, .8) url('http://i.stack.imgur.com/FhHRx.gif') 50% 50% no-repeat;
        }

        /* prevent scrollbar from display during load */
        body.loading {
            overflow: hidden;
        }

        /* display the modal when loading class is added to body */
        body.loading .modal {
            display: block;
        }

        /* FOr centering image */
        * {
            margin: 0;
            padding: 0;
        }

        .imgbox {
            float: right;
            display: grid;
            height: 100%;
        }

        .center-fit {
            max-width: 100%;
            max-height: 100vh;
            margin: auto;
        }

    </style>


</head>
<body>

<div class="modal"></div>

<h2>Watershed Image Segmentation</h2>

<div>
    <div class="caption"><input type="file" id="fileInput" name="file"/></div>

    <form name="options">

        <br>
        Dilation of object boundary to background (so region in the background is guarantee tobe the background):
        <br>
        <input type="range" id="trackbarDilation" value="3" min="0" max="6" step="1" oninput="callback()">
        <input type="text" id="weightDilation" size="3" value="3"/>


        <br>
        Foreground Minimum Threshold:
        <input type="range" id="trackbarThreshold" value="0.5" min="0" max="1" step="0.1" oninput="callback()">
        <input type="text" id="weightValueTrackbar" size="3" value="0.5"/>
        <br>


    </form>

    <P>
        <button onClick="watershed()" type="button" id="clickMe">
            Run Algorithm
        </button>
    </P>
    <div class="imgbox">

        <img class="center-fit" id="imageSrc" alt="No Image"/>
        <canvas class="center-fit" id="output"></canvas>
        Threshhold Image<br>
        <canvas class="center-fit" id="threshold"></canvas>
        Image Background<br>
        <canvas class="center-fit" id="background"></canvas>
        Distance Transform<br>
        <canvas class="center-fit" id="distanceTransform"></canvas>
        Foreground<br>
        <canvas class="center-fit" id="foreground"></canvas>
        Markers<br>
        <canvas class="center-fit" id="markers"></canvas>
        Watershed Image Segmentation<br>
        <canvas class="center-fit" id="watershed"></canvas>

    </div>
</div>


<script type="text/javascript">
    document.body.classList.add("loading");

    let imgElement = document.getElementById("imageSrc");
    let inputElement = document.getElementById("fileInput");
    inputElement.addEventListener("change", (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);

    }, false);


    let x = document.createElement('INPUT');
    x.setAttribute('type', 'range');

    let weightValueThreshold = document.getElementById('weightValueTrackbar');
    let trackbarThreshold = document.getElementById('trackbarThreshold');
    trackbarThreshold.oninput = function () {
        weightValueThreshold.setAttribute('value', trackbarThreshold.value);
    };

    let weightValueDilation = document.getElementById('weightDilation');
    let trackbarDilation = document.getElementById('trackbarDilation');
    trackbarDilation.oninput = function () {
        weightValueDilation.setAttribute('value', trackbarDilation.value);
    };

    function watershed() {
        let src = cv.imread(imgElement);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let opening = new cv.Mat();
        let coinsBg = new cv.Mat();
        let coinsFg = new cv.Mat();
        let distTrans = new cv.Mat();
        let unknown = new cv.Mat();
        let markers = new cv.Mat();


// gray and threshold image
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
        cv.imshow('threshold', gray);

// get background
        let dTrackbar = parseFloat(trackbarDilation.value);
        let M = cv.Mat.ones(dTrackbar, dTrackbar, cv.CV_8U);
        cv.erode(gray, gray, M);
        cv.dilate(gray, opening, M);
        cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), dTrackbar);
        cv.imshow('background', coinsBg);
// distance transform

        cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
        cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);
        cv.imshow('distanceTransform', distTrans);
// get foreground
        let y = parseFloat(trackbarThreshold.value);
        cv.threshold(distTrans, coinsFg, y, 255, cv.THRESH_BINARY);

        cv.imshow('foreground', coinsFg);

        coinsFg.convertTo(coinsFg, cv.CV_8U, 1, 0);
        cv.subtract(coinsBg, coinsFg, unknown);
// get connected components markers
        cv.connectedComponents(coinsFg, markers);
        for (let i = 0; i < markers.rows; i++) {
            for (let j = 0; j < markers.cols; j++) {
                markers.intPtr(i, j)[0] = markers.ucharPtr(i, j)[0] + 1;
                if (unknown.ucharPtr(i, j)[0] == 255) {
                    markers.intPtr(i, j)[0] = 0;
                }
            }
        }
        cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0);
        cv.watershed(src, markers);
        cv.imshow('markers', markers);
// draw barriers
        for (let i = 0; i < markers.rows; i++) {
            for (let j = 0; j < markers.cols; j++) {
                if (markers.intPtr(i, j)[0] == -1) {
                    src.ucharPtr(i, j)[0] = 0; // R
                    src.ucharPtr(i, j)[1] = 255; // G
                    src.ucharPtr(i, j)[2] = 0; // B
                }
            }
        }
        cv.imshow('watershed', src);
        src.delete();
        dst.delete();
        gray.delete();
        opening.delete();
        coinsBg.delete();
        coinsFg.delete();
        distTrans.delete();
        unknown.delete();
        markers.delete();
        M.delete();
    }

    function onOpenCvReady() {
        document.body.classList.remove("loading");
    }
</script>
<script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
<
/body>
< /html>;
