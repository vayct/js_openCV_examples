<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Watershed Image Segmentation</title>
    <style type="text/css">
        /* display loading gif and hide webpage */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: rgba(255, 255, 255, .8) url('http://i.stack.imgur.com/FhHRx.gif') 50% 50% no-repeat;
        }

        /* prevent scrollbar from display during load */
        body.loading {
            overflow: hidden;
        }

        /* display the modal when loading class is added to body */
        body.loading .modal {
            display: block;
        }

        /* FOr centering image */
        * {
            margin: 0;
            padding: 0;
        }

        .imgbox {
            float: right;
            display: grid;
            height: 100%;
        }

        .center-fit {
            max-width: 100%;
            max-height: 100vh;
            margin: auto;
        }

    </style>


</head>
<body>

<div class="modal"></div>

<h2>Watershed Image Segmentation</h2>

<div>
    <div class="caption"><input type="file" id="fileInput" name="file"/></div>

    <form name="options">

        <br>
        Erosion Iteration: <span id="weightErosion">2</span>
        <input type="range" id="trackbarErosion" value="2" min="0" max="10" step="1" oninput="callback()">
        <br>

        <br>
        Dilation Iteration: <span id="weightDilation">2</span>
        <input type="range" id="trackbarDilation" value="2" min="0" max="10" step="1" oninput="callback()">
        <br>

        <br>
        Foreground Minimum Threshold: <span id="weightThreshold">1</span>
        <input type="range" id="trackbarThreshold" value="0.5" min="0" max="1" step="0.1" oninput="callback()">
        <br>



    </form>

    <P>
        <button onClick="watershed()" type="button" id="clickMe">
            Run Algorithm
        </button>
    </P>
    <h6 id="status"></h6>
    <div class="imgbox">

        <img class="center-fit" id="imageSrc" alt="No Image"/>

        <canvas class="center-fit" id="output"></canvas>

        Converting the image to grayscale and threshhold it with Otsu's binarization<br>
        <canvas class="center-fit" id="threshold"></canvas>

        Eroding the foreground region:<br>
        <canvas class="center-fit" id="erode"></canvas>

        Dilating the threshold image so that the background region is reduced:<br>
        <canvas class="center-fit" id="dilate"></canvas>


        Image Background<br>
        <canvas class="center-fit" id="background"></canvas>
        Distance Transform and Normalize<br>
        <canvas class="center-fit" id="distanceTransform"></canvas>
        Foreground<br>
        <canvas class="center-fit" id="foreground"></canvas>
        White part are part of the foreground, black parts are unknown<br>
        <canvas class="center-fit" id="unknown"></canvas>
        Watershed Image Segmentation<br>
        <canvas class="center-fit" id="watershed"></canvas>

    </div>
</div>


<script type="text/javascript">
    document.body.classList.add("loading");

    let imgElement = document.getElementById("imageSrc");
    let inputElement = document.getElementById("fileInput");
    inputElement.addEventListener("change", (e) => {
        imgElement.src = URL.createObjectURL(e.target.files[0]);

    }, false);


    let x = document.createElement('INPUT');
    x.setAttribute('type', 'range');

    let weightValueThreshold = document.getElementById('weightThreshold');
    let trackbarThreshold = document.getElementById('trackbarThreshold');
    trackbarThreshold.oninput = function () {
        weightValueThreshold.innerHTML = trackbarThreshold.value;
    };

    let weightValueErosion = document.getElementById('weightErosion');
    let trackbarErosion = document.getElementById('trackbarErosion');
    trackbarErosion.oninput = function () {
        weightValueErosion.innerHTML = trackbarErosion.value;
    };

    let weightValueDilation = document.getElementById('weightDilation');
    let trackbarDilation = document.getElementById('trackbarDilation');
    trackbarDilation.oninput = function () {
        weightValueDilation.innerHTML = trackbarDilation.value;
    };

    function watershed() {
        let src = cv.imread(imgElement);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let opening = new cv.Mat();
        let background = new cv.Mat();
        let foreground = new cv.Mat();
        let distTrans = new cv.Mat();
        let unknown = new cv.Mat();
        let markers = new cv.Mat();

        src.convertTo(src, cv.CV_32F);


        let sText = document.getElementById('status');
        let matK = new cv.Mat(1, src.rows * src.cols, cv.CV_32F);
        cv.cvtColor(matK, matK, cv.COLOR_GRAY2RGBA);


        let i = 0;
        for (let x = 0; x < src.rows; x++) {
            for (let y = 0; y < src.cols; y++) {
                matK.floatPtr(0, i)[0] = src.floatAt(x, y * src.channels());
                matK.floatPtr(0, i)[1] = src.floatAt(x, y * src.channels() + 1);
                matK.floatPtr(0, i)[2] = src.floatAt(x, y * src.channels() + 2);
                matK.floatPtr(0, i)[3] = src.floatAt(x, y * src.channels() + 3);
                i++;

            }
        }


        let label = new cv.Mat();
        let criteria = new cv.TermCriteria(0, 10, 1.0);
        cv.kmeans(matK, 4, label, criteria, 5, cv.KMEANS_RANDOM_CENTERS, dst);
        cv.imshow('output', matK);
// gray and threshold image
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
        cv.imshow('threshold', gray);

// get background
        let eTrackbar = parseFloat(trackbarErosion.value);
        let erosionIteration = cv.Mat.ones(eTrackbar, eTrackbar, cv.CV_8U);
        cv.erode(gray, gray, erosionIteration);
        cv.imshow('erode', gray);

//dilate the gray image so that the background region is reduced
        let dTrackbar = parseFloat(trackbarDilation.value);
        let dilationIteration = cv.Mat.ones(dTrackbar, dTrackbar, cv.CV_8U);
        cv.dilate(gray, opening, dilationIteration);
        cv.imshow('dilate', opening);


        cv.dilate(opening, background, dilationIteration, new cv.Point(-1, -1), dTrackbar);

        cv.imshow('background', background);
// distance transform

        cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
        cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);
        cv.imshow('distanceTransform', distTrans);
// get foreground
        let y = parseFloat(trackbarThreshold.value);
        cv.threshold(distTrans, foreground, y, 255, cv.THRESH_BINARY);

        cv.imshow('foreground', foreground);

        foreground.convertTo(foreground, cv.CV_8U, 1, 0);
        cv.subtract(background, foreground, unknown);
        cv.imshow('unknown', unknown);
// get connected components markers
        cv.connectedComponents(foreground, markers);
        for (let i = 0; i < markers.rows; i++) {
            for (let j = 0; j < markers.cols; j++) {
                markers.intPtr(i, j)[0] = markers.ucharPtr(i, j)[0] + 1;
                if (unknown.ucharPtr(i, j)[0] == 255) {
                    markers.intPtr(i, j)[0] = 0;
                }
            }
        }
        cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0);
        cv.watershed(src, markers);
// draw barriers
        for (let i = 0; i < markers.rows; i++) {
            for (let j = 0; j < markers.cols; j++) {
                if (markers.intPtr(i, j)[0] == -1) {
                    src.ucharPtr(i, j)[0] = 0; // R
                    src.ucharPtr(i, j)[1] = 255; // G
                    src.ucharPtr(i, j)[2] = 0; // B
                }
            }
        }
        cv.imshow('watershed', src);
        src.delete();
        dst.delete();
        gray.delete();
        opening.delete();
        background.delete();
        foreground.delete();
        distTrans.delete();
        unknown.delete();
        markers.delete();
        erosionIteration.delete();
        dilationIteration.delete();
    }

    function getMat(src) {
        let text = "";

        for (let x = 0; x < src.rows; x++) {
            for (let y = 0; y < src.cols; y++) {

                text += '[' + src.floatAt(x, y * src.channels()) + ' ';
                text += src.floatAt(x, y * src.channels() + 1) + ' ';
                text += src.floatAt(x, y * src.channels() + 2) + ' ';
                text += src.floatAt(x, y * src.channels() + 3) + ' ]';
            }

            text += '\n';
        }
        return text;
    }

    function getDescription(src) {
        let text =
            'image width: ' + src.cols + '\n' +
            'image height: ' + src.rows + '\n' +
            'image size: ' + src.size().width + '*' + src.size().height + '\n' +
            'image depth: ' + src.depth() + '\n' +
            'image channels ' + src.channels() + '\n' +
            'image type: ' + src.type() + '\n' +
            'image total: ' + src.total() + '\n' +
            src + '\n';
        return text;
    }

    function onOpenCvReady() {
        document.body.classList.remove("loading");
    }


</script>
<script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>

<
/body>
< /html>;
